___TERMS_OF_SERVICE___

By creating or modifying this file you agree to Google Tag Manager's Community
Template Gallery Developer Terms of Service available at
https://developers.google.com/tag-manager/gallery-tos (or such other URL as
Google may provide), as modified from time to time.


___INFO___

{
  "type": "TAG",
  "id": "cvt_temp_public_id",
  "version": 1,
  "securityGroups": [],
  "displayName": "Quantcast Measure",
  "categories": [
    "ANALYTICS",
    "ATTRIBUTION",
    "MARKETING"
  ],
  "brand": {
    "id": "quantcast",
    "displayName": "Quantcast",
    "thumbnail": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAeKADAAQAAAABAAAAeAAAAAAI4lXuAAANh0lEQVR4Ae1cCbBUxRU9BBBRETcUhbCquLCJATUibqBs4gIqCkkwiZoyJUbLlEuVYpYylWhMhJjExKSKkIi7JoACKsqigihGcEFE+IAsghugKIKacxgn/zO+mbn95vV//7/qWzU1/7/pd/vee3q5fft2N8C4L79EoMxa4BuZ1SwotsMCAeCMN4QAcAA44xbIuHqhBweAM26BjKsXenAAOOMWyLh6oQcHgDNugYyrF3pwADjjFsi4eqEHB4AzboGMqxd6cAA44xbIuHqhBweAM26BjKsXenAAOOMWyLh6oQcHgDNugYyrF3pwADjjFsi4eqEHB4AzboGMqxd6cAA44xbIuHqhBweAM26BjKsXenAAOOMWyLh6oQcHgDNugYyr1ygN/VrvDpxwEHAgvw/YDWjJzwFNgX12BTZ+Bryzpfqzjn8/uw5YujENSd3rbMIxsTd167QXsP9Xeul7f+q3S0Pgg0+B97fyw+9X3wfmvQMsfBfY7ukijVoBuDGVPv5AYEBbftoAXfZzN9zSD4HHVgCP8jNzNfDJ5+48fL1xxN7A6dTrNH5ObAU0dbTqlm3AU9Tp768Bk6uAz75ITtIGPi9hacoWe1kX4JqjgRZswUnRJvby3/8XuI0f9fi0aBAb7I29gF4HJCfBu58A4xYCt74EbNleOV8vAO/CHnvJkcD138oNw5WLGc1Bw90tNMTYl4GPEzBGdC1ffzqkPYHtCRy9/9d/S+rJ2x+xYzwL3L2kMo6JA9yLSt/bH2i3Z2WCuby9fgsw8nHg8VUub7mXPYg+w8TTgD4chmuLbucoddUcIO6onegy6aLDgVlDaxdcGVpOzGNnAFcf5c/sJxPUBefXLrjS5oruwH3sMLtyuotDiQAsJ+oPfegknAo0iSlIHOFrvtOQMtxyPIc09jDN/UlRAzK6tgdHhzNzHn9SfF34DD0YePIsYF+uMlyp4iFaLeThgcCQDq5V+ys/Zw1w6iPJeKO39QauZC+qC7TkAy7BHgQ20PewkvCpiG4+rm6BK2W0Dv3zSRWptePlyzrXHXAl0KFcjt11ipteFfXgkYcCEzgkxqXFbJHTVwLyGNd+DLzLlrlXE3renFNb7QFo3utRgad61Wzgd/Sw45DW65MGAxr645DWttNX5YIYa+kESr+GHO87ESQFQboyFnBUizicuUKZAfz1Ndu7sQGWtzzzHE7+jov6zVy3/pZLm4lvAks+LC9kGwJ9LuegOGvpz+l6DpyUM3T5mqpLKHAx91yg2S7Vz6x/qcFq2fbk28CnZYIxx3D9fB1jBFp2NdBkb6SP2Xi632OL7sUCWLLMP89tHag7be9iq7thLsOQXMy7UnMa+4ae9Cq7AY0cetWyjcBh/wK2EWwrTRuSi0pZy6ucwo1XPxNvqdZ5H+D+AZSTDctK89YB336g/PLJwVTVVQ/t6AbuNrZkrVMveSoeuKpZESsZcPBkBjXYgq3UoTlw8RHW0gT2m+7g3v0Go1n3xQNXkr3CmPRx9wNPcEi30JQqYPSs8uCKl3MP1jzy6oW5ucQijOaiM6dQeA5ZSVFPTg9T2cu0OWEhzX8HTygf+lNrXzAc6Mb50Uq/nM+RZZ61dOlyjWjbCf2A4fRtCkkj4H+WA79gfS9uKPy1+P/OPXjUYXZwVe3lbGlJgiue89cD33tCf9lIu1aju5YvO7KTG7gTFicHrqTTjtLFHOXe4rSSJwH74FI6ZPcAZz3qBq54OAP8Y4Oh8sLds4TBj9fz/yX7Pbkq58xYuWrToxxd0rlcierfNedeSjCSpo844o2czjU8pzXZr8tEYNhU4OX34tXkNEQrFrv6IltFGprbjAfe49LHFylitWKUfaeqG421sIihWnC4X/cDtngOkxbqyTn3BY4kvmg/yqNlY6Xk1IMHtrVX9zd6zD7BlSTaEx7HJYmVBrUrXlK/WcGdvNwvuJIyCXDFxwngUgYSszx9wXlDe7W1QXcsItDGrcJS8mstaiU5OvWFzABrj7dva5taL9HLq9psK1tpKaW/zFpt43IsAwt7M1JWSNosUTaGhao2Ac+vt5SsG2XMALfeA9jDGNl5KsElkcVMM4z1Kex4CNfFhSTfYvfGhU+j/5+2Mvp5XX1qBljJcVZ62tijrPzKlXOpryXBLCQl/VlJocj6RGaAXYywjMNYbdJyh/qi9Ih6Vkz++pLdmZffC8BKHKtNkrcux85CSs8tJAVCrLS+lnWzylWsnBlg6xAtQ/teHhUqo30EJeBZqJIhWrptyCrAxvW/xcZeylh3mKJadF3XrRKDRekbyU+nDSykYIF1E8DCz1JGS5/mEcufqHejtip1esJC0k0RpvpEZoCtRpDySSa5W4zZfk9LqVyZqIaq3SYrKYOzPpEZ4CjDFFO0XbNiv8R7rvSZp8/mOrzIWtUF4CgnyaXxdnRoTPG0TfYtM8AuRjjJGPGyqKJc58ln5M78KCU2SmAXgKMaqnKmrNSXCQH1iaLsFSm/EuO0Q2ShU1pZSpUuo0RvbX4r1zm/CXBGe+Zz9f76ezojZKHtdLe1zVdIazhEW3Xrb6yrsI60/jcDvJXGsYYElQmpZLm4pNChEvq0AV9IP2GO8o86Vz/tui9gHTF0VHNTRCNVvpb12EtHhjq7O2R8VEuazl9mgCXelBU2IdXjriIQcUiZhi+cV/rE3rg+QL+vhsrRTMKz0rQS8isdxkpK/qsv5AZwlV2tHx7J5ZJx6ZLnOqxjrueWiyxpzXt/fx4i55njCyPyl/L8Cr+Vp1yMlCFijYad3YF5zRw5fFKzIg6la51OAK/iPLwoYg6LqlS7M2PZ01zoDeZJK1XFQlr3zqBnbT1svYayz+cQXYzkXSsV1ULKYdYJA53m90E9WjC75PtMd2IdUbtfLnU6i/inV+zsR3AO/W7EPFqMwyKm0wyfBihh3ULW6JV46UB1ObZ/edVSa65MT04ltzs2YAt3pSH9k87lbuwgFx0BvD4id6BOudNxyBlgJa8rmdxKfzyJTpCDV60rGq6cY+VuK6f48Z0G8P6x2D5CqeZL6exd08Mmg6WUwLjjRODwGmBqD/sCTkMLLwAeGsB8dPZuF2qIgTfd5PJCfjPhHM6XFtLFIxJQ55Be48dCz3MoVRJcUlcjKHdZd2CUoy9ZQFuPUd57sXe1Lm5Fr1/3h5QbIYrx0PPdG+X8iqicaP2uaUHAK/NTmSnKLNGUWY6ce7AYTmQ6p3UuVnmdGdap/7En2B2vK2YzuZ1Gq5Q09ypvy0pTV/Jc0Spr6Vy5i+lQzh7K0wkt3d7Ll1Z0bA7ftx7B1Vr8N4oP5BmU+HZKm63Jpzc92BlnAY0JngtpW+9XLzLn983yLXBPzkPPDAM6x/RYNZfrnPDMNS4Ssj72FB0+s6bx1OT+0Fu5fO05a+lLaEgoQarn2qOB8w9xO2+lA3xKAV6+uQTzr36KDbDe10Urd55cvpJiJV5cnzs+qqFGAX/NlTrRpx0bBRR0JdGx7BVWT7mwnjHzgJ9zeI5Dg9sB/x5UHUVz5aF7sORPvMxVxzrqpnBozeOjXdhodVeYy6nCvAyjngDGL87/V/q7IoDFWsPu5d1KV5LGr4q69WPvrWRe1HEXH55yJfZ4YCmP0061c7AM4yW56QaYxzlv1TVSKqzLMipK/rEL3RLro3gk+Ux+j+txmYoB1oGpIVM4ZLyepCqV89Lwp0thKiU5ezfOtUe5Kq2v2PtKRT7hodw1iMXKRD13XiZFMRHIjyzP3b+oGHF+9yeqbG0+0zUJXF3AJa02Sr5ZdNLmrstdxagARG2TVi3DHit//DVKrop7cE2muoKvL+c9ORV1hcb0Ar7jEE0rJrfi2D3utYczi/FxfX7rAmDE9Pg3BiUKsITXkkSHra97NtejXRVKuryWSlHHVeLUI29f1yacTyfnFYZVfdIqLoGGs56f0o5lVlslxajYiy7FXetY3TGljzUprhS//G/vcTk1qQrQrk4pvh9uzYFRahcpz9P1W0O/rrLQ1qGmgqRIusm5u4U9N4kbdb0CnFdaYbiTmcaz4zrhtoBLik2eh+6jfHgZoGWC5lTN+8oc0VUOUcEWhUaHTAbedIib5+ty+RbQupT09Da5j6JZrt67dtB0RbKO3D5CHZVckRTVCsCFwuqeqD70cpW5oYT6/Ef7xzotuJpDodJoVuvDvxUfVnw6Sm/tVo3vt3MNU6q4TzwtOntj55LJ/6dRS435/xeCUz9dBp6/EFwBkB0f6qlh/jk6bws2lL9yKa6kqQAcV9hi743hMHnTMblff80w6PXPRTeGYu9n+TkHz/pPP2M4UgfIZq+t/H7l+m+NnTXIRA/eWaXwX00LJL5Mqsk8/J2+BQLA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4lCAB7NW/6zAPA6WPgVYIAsFfzps88AJw+Bl4l+B+TrEVh9UYg2wAAAABJRU5ErkJggg\u003d\u003d"
  },
  "description": "Server Side Template for Quantcast Measure integration.",
  "containerContexts": [
    "SERVER"
  ]
}


___TEMPLATE_PARAMETERS___

[
  {
    "type": "TEXT",
    "name": "qacct",
    "displayName": "P-Code",
    "simpleValueType": true
  },
  {
    "type": "TEXT",
    "name": "labels",
    "displayName": "Labels",
    "simpleValueType": true
  },
  {
    "type": "TEXT",
    "name": "orderId",
    "displayName": "Order Id (Optional)",
    "simpleValueType": true
  },
  {
    "type": "TEXT",
    "name": "revenue",
    "displayName": "Revenue (Optional)",
    "simpleValueType": true
  },
  {
    "type": "CHECKBOX",
    "name": "httpOnlyCookie",
    "checkboxText": "Http Only Cookie",
    "simpleValueType": true,
    "defaultValue": false
  },
  {
    "type": "PARAM_TABLE",
    "name": "parameters",
    "displayName": "Additional URL Parameters",
    "paramTableColumns": [
      {
        "param": {
          "type": "TEXT",
          "name": "key",
          "displayName": "Key",
          "simpleValueType": true
        },
        "isUnique": true
      },
      {
        "param": {
          "type": "TEXT",
          "name": "value",
          "displayName": "Value",
          "simpleValueType": true,
          "canBeEmptyString": false
        },
        "isUnique": false
      }
    ],
    "newRowTitle": "URL Parameter",
    "alwaysInSummary": true,
    "newRowButtonText": "Add URL Parameter"
  }
]


___SANDBOXED_JS_FOR_SERVER___

// Imports
const encodeUriComponent = require('encodeUriComponent');
const generateRandom = require('generateRandom');
const JSON = require('JSON');
const Object = require('Object');
const getType = require('getType');
const getTimestamp = require('getTimestamp');
const getTimestampMillis = require('getTimestampMillis');
const sha256Sync = require('sha256Sync');
const computeEffectiveTldPlusOne = require('computeEffectiveTldPlusOne');

// Import With Permissions
const logToConsole = require('logToConsole');
const sendPixelFromBrowser = require('sendPixelFromBrowser');
const getCookieValues = require('getCookieValues');
const setCookie = require('setCookie');
const returnResponse = require('returnResponse');
const getAllEventData = require('getAllEventData');
const getRequestHeader = require('getRequestHeader');

// Constants
const DOMAIN_QSERVE = 'quantserve.com';
const DOMAIN_QCOUNT = 'quantcount.com';
const FPA_COOKIE = '__qca';
const MAX_USER_ID = 2147483647;
const COOKIE_EXP_TIME = 33868800;
const USERHASH_TYPE_EMAIL = 0;
const USERHASH_TYPE_SHA256 = 1;
const USERHASH_TYPE_UNKNOWN = 2;
const VALID_SHA_CHARACTERS = "abcdefABCDEF0123456789";

// Read Request Fields
const host = getRequestHeader('host');

// Read Data Fields
const pcode                   = data.qacct;
const labels                  = data.labels;
const orderId                 = data.orderId;
const revenue                 = data.revenue;
const additionalUrlParameters = data.parameters;
const httpOnlyCookie          = data.httpOnlyCookie;

// Read Events Fields
const events       = getAllEventData();
const pageLocation = events.page_location;
const pageReferrer = events.page_referrer;
const uid          = events.user_id || '';
const cmpConsent   = events.cmpConsents;
const clientId     = events.client_id;

const pageHostname = computeEffectiveTldPlusOne(pageLocation);
const serverHostname = computeEffectiveTldPlusOne(host);
const isOnCustomDomain = pageHostname === serverHostname;

function getFpa() {
  // If custom domain is not setup the closest we have to a fisrt party identifier is the
  // client_id that is added by gtm.
  if(!isOnCustomDomain) {
    return '&fpa=G1-' + sha256Sync(clientId, {outputEncoding: 'hex'}) + '&fpan=0';
  }
  // If custom domain is setup we can actually use the http call to set a fisrt party cookie.
  // This persists better that ones set using javascript.
  var fpan = 0;
  var fpa = getCookieValues(FPA_COOKIE)[0];

  if (!fpa) {
    fpa = 'G0-' + generateRandom(0, MAX_USER_ID) + '-' +  getTimestampMillis();
    fpan = 1;

    setCookie(FPA_COOKIE, fpa, {
      'max-age': COOKIE_EXP_TIME,
      domain: 'auto',
      path: '/',
      httpOnly: data.httpOnlyCookie,
      secure: true,
      samesite: 'none'
    });
  }
  return '&fpa=' + fpa + '&fpan=' + fpan;
}

function removeFPA() {
  setCookie(FPA_COOKIE, "", {
      'max-age': 0,
      domain: 'auto',
      path: '/',
  });
}

// Parse USPrivacy consent object
function resolveUSPrivacyConsent(uspApiObj){
  if (!uspApiObj) {
    return { isAllowed: true, data: "" };
  }

  if (getType(uspApiObj.uspString) !== 'string') {
    return { isAllowed: true, data: "" };
  }
  return { isAllowed: true, data: uspApiObj.uspString ? '&us_privacy=' + uspApiObj.uspString : '' };  
}

// Parse TCF V2 consent object
function resolveGdprConsent(tcfApiObj){
  if (!tcfApiObj) {
    return {isAllowed: true, data: ""};  
  }  
  
  // Constants
  var PURPOSE_DATA_COLLECT = '1';

  var QC_TCF_VENDOR_ID = 11;
  var QC_TCF_REQUIRED_PURPOSES = [PURPOSE_DATA_COLLECT, '3', '7', '8', '9', '10'];
  var QC_TCF_CONSENT_FIRST_PURPOSES = [PURPOSE_DATA_COLLECT, '3'];
  var QC_TCF_CONSENT_ONLY_PUPROSES = [PURPOSE_DATA_COLLECT, '3'];

  var gdprConsentObj = {};
  var gdprApplies = tcfApiObj.gdprApplies;
  if (!gdprApplies) {
    gdprConsentObj.data = "&gdpr=0";
  } else {
    gdprConsentObj.data = tcfApiObj.tcString? '&gdpr=1&gdpr_consent=' + tcfApiObj.tcString : '&gdpr=0';
  }
  
  var purposes = tcfApiObj.purpose;
  var vendors = tcfApiObj.vendor;
  var qcConsent = vendors && vendors.consents && vendors.consents[QC_TCF_VENDOR_ID];
  var qcInterest = vendors && vendors.legitimateInterests && vendors.legitimateInterests[QC_TCF_VENDOR_ID];
  var restrictions = tcfApiObj.publisher ? tcfApiObj.publisher.restrictions : {};
  
  // Check whether QC is allowed or not to collect the data
  gdprConsentObj.isAllowed = QC_TCF_REQUIRED_PURPOSES
    .map(function (purpose) {
      var purposeConsent = purposes && purposes.consents ? purposes.consents[purpose] : false;
      var purposeInterest = purposes && purposes.legitimateInterests ? purposes.legitimateInterests[purpose] : false;

      var qcRestriction = restrictions && restrictions[purpose] ? restrictions[purpose][QC_TCF_VENDOR_ID] : null;

      if (qcRestriction === 0) {
        // publisher has flatly disallowed purpose for Quantcast :-(
        return false;
      }

      // Seek consent or legitimate interest based on our default legal
      // basis for the purpose, falling back to the other if possible.
      if (
        qcConsent && // we have positive vendor consent
        purposeConsent && // there is positive purpose consent
        qcRestriction !== 2 && // publisher does not require legitimate interest
        // purpose is a consent-first purpose or publisher has explicitly restricted to consent
        (QC_TCF_CONSENT_FIRST_PURPOSES.indexOf(purpose) != -1 ||
          qcRestriction === 1)
      ) {
        return true;
      } else if (
        qcRestriction !== 1 && // publisher does not require consent
        qcInterest && // we have legitimate interest for vendor
        purposeInterest && // there is legitimate interest for purpose
        // purpose's legal basis does not require consent
        QC_TCF_CONSENT_ONLY_PUPROSES.indexOf(purpose) == -1 &&
        // purpose is a legitimate-interest-first purpose or publisher has explicitly restricted to legitimate interest
        (QC_TCF_CONSENT_FIRST_PURPOSES.indexOf(purpose) == -1 ||
          qcRestriction === 2)
      ) {
        return true;
      }
      return false; // no legal basis :-(
    }).reduce(function (a, b) {
      return a && b;
    }, true);

  return gdprConsentObj;
}

// Resolve the consent object received from the web container
// Returns a consent string and a boolean value used for deciding which domain to use
function resolveConsent(cmpConsentsStr) {
  if (!cmpConsentsStr) {
    return {isAllowed: true, gdprConsentParams:"", usPrivacyParams:""};
  }

  var cmpConsentData = JSON.parse(cmpConsentsStr);

  const usPrivacyConsent  = resolveUSPrivacyConsent(cmpConsentData.uspApi);
  const gdprConsent = resolveGdprConsent(cmpConsentData.tcfApi);

  return {
    isAllowed: usPrivacyConsent.isAllowed && gdprConsent.isAllowed, 
    gdprConsentParams: gdprConsent.data,
    usPrivacyParams: usPrivacyConsent.data
  };
}

// Determines if a string is a valid email address based on the following rules:
// 1. Email Address must be at least 3 characters long.
// 2. Email Address must contain @ character.
// 3. Email Address must contain minimum 1 and maximum 2 Dots after @ character and there should minimum one non-special character between @ and Dot.
// 4. Dot must not be the last character in the Email Address and Dots cannot be in consecutive repetition.
function isValidEmailAddress(emailString) {
  if (!emailString) return false;
  //Check minimum valid length of an Email.
  if (emailString.length <= 2) {
    return false;
  }
  //Check if email has @ character.
  if (emailString.indexOf("@") == -1) {
    return false;
  }

  var parts = emailString.split("@");
  var dot = parts[1].indexOf(".");
  var len = parts[1].length;
  var dotSplits = parts[1].split(".");
  var dotCount = dotSplits.length - 1;


  //Check whether Dot is present and is at least 1 character after @.
  if (dot == -1 || dot < 2 || dotCount > 2) {
    return false;
  }

  //Check whether Dot is not the last character and dots are not repeated.
  for (var i = 0; i < dotSplits.length; i++) {
    if (dotSplits[i].length == 0) {
      return false;
    }
  }

  return true;
 }

// Determines if a string is a valid SHA256 hashed string based on the following rules:
// 1. string is exactly 64 characters long
// 2. string contains only characters belonging to [a-fA-F0-9]
function isValidSHA256Hash(hashString) {
  if (!hashString) return false;
  if(hashString.length != 64) return false;
  
  for(var char of hashString) {
    if(VALID_SHA_CHARACTERS.indexOf(char) == -1 ) return false;
  }
  
  return true;
}

// Returns the SHA256-hashed user-provided id id along with the id type. 
function getUh() {
  var uht = USERHASH_TYPE_UNKNOWN;
  var uh = '';
  if(isValidSHA256Hash(uid)) {
    uht = USERHASH_TYPE_SHA256;
    uh = uid;
  } else {
    if(isValidEmailAddress(uid)) {
      uht = USERHASH_TYPE_EMAIL;
    }
    if(uid) {
      uh = sha256Sync(uid.toLowerCase(), {outputEncoding: 'hex'});
    }
  }
  return '&uh=' + uh + '&uht=' + uht;
}

function objectToUrl(obj) {
  if(getType(obj) !== 'object') {
   return ''; 
  }
  var str = '';
  Object.keys(obj).forEach((key)=> {
    str += "&"+ key + "=" + encodeUriComponent(obj[key]);
  });
  return str;
}

// Consent Resolution
const consentData = resolveConsent(cmpConsent);
if(!consentData.isAllowed) {
  // Remove FPA Cookie 
  removeFPA();
}
const target = consentData.isAllowed ? DOMAIN_QSERVE : DOMAIN_QCOUNT;
const gdprConsentParams = consentData.gdprConsentParams;
const usPrivacyParams = consentData.usPrivacyParams;

var url = 'https://pixel.' + target + '/pixel/' + pcode + '.gif' +
    '?r=' + generateRandom(0, MAX_USER_ID) +
    '&source=gtmss' + 
    '&labels=' + encodeUriComponent(labels) +
    '&url=' + encodeUriComponent(pageLocation) +
    '&d=' + encodeUriComponent(computeEffectiveTldPlusOne(pageLocation)) +
    '&ref=' + encodeUriComponent(pageReferrer) +
    getUh() +
    (consentData.isAllowed ? getFpa() : '') +
    (orderId? '&orderId=' + orderId : '') +
    (revenue? '&revenue=' + revenue : '') +
    gdprConsentParams +
    usPrivacyParams +
    '&et=' + getTimestamp() +
    objectToUrl(additionalUrlParameters);

logToConsole(url);

if(sendPixelFromBrowser(url)) {
  // Call data.gtmOnSuccess when the tag is finished.
  data.gtmOnSuccess();
  logToConsole("sending pixel from browser successful");
} else {
  data.gtmOnFailure();
}  

// Flush response back to browser for setting cookies
returnResponse();


___SERVER_PERMISSIONS___

[
  {
    "instance": {
      "key": {
        "publicId": "get_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "cookieAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "cookieNames",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "__qca"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "return_response",
        "versionId": "1"
      },
      "param": []
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "logging",
        "versionId": "1"
      },
      "param": [
        {
          "key": "environments",
          "value": {
            "type": 1,
            "string": "debug"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "set_cookies",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedCookies",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "name"
                  },
                  {
                    "type": 1,
                    "string": "domain"
                  },
                  {
                    "type": 1,
                    "string": "path"
                  },
                  {
                    "type": 1,
                    "string": "secure"
                  },
                  {
                    "type": 1,
                    "string": "session"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "__qca"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "*"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  },
                  {
                    "type": 1,
                    "string": "any"
                  }
                ]
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_event_data",
        "versionId": "1"
      },
      "param": [
        {
          "key": "eventDataAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "send_pixel_from_browser",
        "versionId": "1"
      },
      "param": [
        {
          "key": "allowedUrls",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "urls",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 1,
                "string": "https://pixel.quantserve.com/"
              },
              {
                "type": 1,
                "string": "https://pixel.quantcount.com/"
              }
            ]
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  },
  {
    "instance": {
      "key": {
        "publicId": "read_request",
        "versionId": "1"
      },
      "param": [
        {
          "key": "headerWhitelist",
          "value": {
            "type": 2,
            "listItem": [
              {
                "type": 3,
                "mapKey": [
                  {
                    "type": 1,
                    "string": "headerName"
                  }
                ],
                "mapValue": [
                  {
                    "type": 1,
                    "string": "Host"
                  }
                ]
              }
            ]
          }
        },
        {
          "key": "headersAllowed",
          "value": {
            "type": 8,
            "boolean": true
          }
        },
        {
          "key": "requestAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "headerAccess",
          "value": {
            "type": 1,
            "string": "specific"
          }
        },
        {
          "key": "queryParameterAccess",
          "value": {
            "type": 1,
            "string": "any"
          }
        }
      ]
    },
    "clientAnnotations": {
      "isEditedByUser": true
    },
    "isRequired": true
  }
]


___TESTS___

scenarios:
- name: can send Pixel from server successfully
  code: |-
    // Mock pixel request
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).contains(mockFields.qacct + ".gif");
      assertThat(url).contains("&labels="+ mockFields.labels);
      return true;
    });


    // Call runCode to run the template's code.
    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: can set user hash and user hash type as pixel parameters when available
  code: |-
    const sha256Sync = require('sha256Sync');

    const USERHASH_TYPE_EMAIL = 0;
    const USERHASH_TYPE_SHA256 = 1;
    const USERHASH_TYPE_UNKNOWN = 2;

    // test if email ids are identified and hashed
    mockEventData.user_id = "Example@Email.com";
    mock('sendPixelFromBrowser', (url, response, options) => {
      var expectedUh = sha256Sync(mockEventData.user_id.toLowerCase(), {outputEncoding: 'hex'});
      var expectedUht = USERHASH_TYPE_EMAIL;
      var expectedParamString = '&uh=' + expectedUh + '&uht=' + expectedUht;
      assertThat(url).contains(expectedParamString);
      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();

    // test if user ids that are already sha256 hashed are identified
    mockEventData.user_id = "2424633ffdfdf3dc9452b75ea16cfa8f67700e6a4d50b893768966a469c2fdd4";
    mock('sendPixelFromBrowser', (url, response, options) => {
      var expectedUh = mockEventData.user_id ;
      var expectedUht = USERHASH_TYPE_SHA256;
      var expectedParamString = '&uh=' + expectedUh + '&uht=' + expectedUht;
      assertThat(url).contains(expectedParamString);
      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();


    // test if empty or missing user ids are classified as an unknown id type
    mockEventData.user_id = "";
    mock('sendPixelFromBrowser', (url, response, options) => {
      var expectedUh = "";
      var expectedUht = USERHASH_TYPE_UNKNOWN;
      var expectedParamString = '&uh=' + expectedUh + '&uht=' + expectedUht;
      assertThat(url).contains(expectedParamString);
      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: can pass orderId and revenue as pixel parameters when available
  code: |-
    // test empty values of orderId & revenue
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).doesNotContain("orderId");
      assertThat(url).doesNotContain("revenue");
      return true;
    });

    runCode(mockFields);
    assertApi('gtmOnSuccess').wasCalled();

    // test valid values of orderId & revenue
    mockFields.orderId = "12345";
    mockFields.revenue = "100.00";

    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).contains("&orderId=12345");
      assertThat(url).contains("&revenue=100.00");
      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: can read a __qca cookie and pass it in the pixel call
  code: "mock('getRequestHeader', (key, response, options) => {\n  if(key === 'host')\
    \ {\n     return \"analytics.example.com\";\n  }\n});\n\nmock('sendPixelFromBrowser',\
    \ (url, response, options) => {\n  var expectedParamString = '&fpa=G0-a_test_cookie-123456&fpan=0';\n\
    \  \n  assertThat(url).contains(expectedParamString);\n  return true;\n});\n\n\
    mock('getCookieValues', (cookieKey) => {\n  return [\"G0-a_test_cookie-123456\"\
    ];\n});\n\nrunCode(mockFields);\n\n\n"
- name: can set a __qca cookie and pass it in the pixel call
  code: "mock('getRequestHeader', (key, response, options) => {\n  if(key === 'host')\
    \ {\n     return \"analytics.example.com\";\n  }\n});\n\nmock('sendPixelFromBrowser',\
    \ (url, response, options) => {  \n  assertApi('setCookie').wasCalled();\n  assertThat(url).contains(\"\
    fpa=G0-\");\n  assertThat(url).contains(\"fpan=1\");\n  \n  return true;\n});\n\
    \n// Cookie doesn't exist\nmock('getCookieValues', (cookieKey) => {\n  return\
    \ [];\n});\n\n\n// Call runCode to run the template's code.\nrunCode(mockFields);\n\
    \n\n// Verify that the tag finished successfully.\nassertApi('gtmOnSuccess').wasCalled();"
- name: can use client_id when custom domain is not configured
  code: "mock('getRequestHeader', (key, response, options) => {\n  if(key === 'host')\
    \ {\n     return \"something.appspot.com\";\n  }\n});\n\nmock('sendPixelFromBrowser',\
    \ (url, response, options) => {\n  var expectedParamString = '&fpa=G1-a45993dc2138ceb9c9e581bb7053b0776920897fe02b68a720810f2071ea06b0&fpan=0';\n\
    \  \n  assertThat(url).contains(expectedParamString);\n  return true;\n});\n\n\
    runCode(mockFields);\n\n\n"
- name: can parse consent object and fire pixel to quantcount
  code: "mockEventData.cmpConsents = JSON.stringify({\n   \"tcfApi\":{\n      \"cmpId\"\
    :10,\n      \"cmpVersion\":44,\n      \"gdprApplies\":true,\n      \"tcfPolicyVersion\"\
    :2,\n      \"eventStatus\":\"tcloaded\",\n      \"cmpStatus\":\"loaded\",\n  \
    \    \"listenerId\":0,\n      \"tcString\":\"TCFString\",\n      \"isServiceSpecific\"\
    :true,\n      \"useNonStandardStacks\":false,\n      \"purposeOneTreatment\":false,\n\
    \      \"publisherCC\":\"GB\",\n      \"outOfBand\":{\n         \"allowedVendors\"\
    :{},\n         \"disclosedVendors\":{}\n      },\n      \"purpose\":{\n      \
    \   \"consents\":{\n            \"1\":true,\n            \"2\":true,\n       \
    \     \"3\":true,\n            \"4\":true,\n            \"5\":true,\n        \
    \    \"6\":true,\n            \"7\":true,\n            \"8\":true,\n         \
    \   \"9\":true,\n            \"10\":true\n         },\n         \"legitimateInterests\"\
    :{\n            \"1\":false,\n            \"2\":true,\n            \"3\":true,\n\
    \            \"4\":true,\n            \"5\":true,\n            \"6\":true,\n \
    \           \"7\":true,\n            \"8\":true,\n            \"9\":true,\n  \
    \          \"10\":true\n         }\n      },\n      \"vendor\":{\n         \"\
    consents\":{\n            \"11\":false,\n            \"12\":false\n         },\n\
    \         \"legitimateInterests\":{\n            \"11\":false,\n            \"\
    12\":false\n         }\n      },\n      \"specialFeatureOptins\":{\n         \"\
    1\":true,\n         \"2\":true\n      },\n      \"publisher\":{\n         \"consents\"\
    :{},\n         \"legitimateInterests\":{},\n         \"customPurpose\":{\n   \
    \         \"consents\":{},\n            \"legitimateInterests\":{}\n         },\n\
    \         \"restrictions\":{}\n      },\n      \"addtlConsent\":\"\"\n   },\n\
    \   \"uspApi\":{\n      \"version\":1,\n      \"uspString\":\"1---\"\n   }\n});\n\
    \n// test if the gdpr & usp_api strings are added to the URL\nmock('sendPixelFromBrowser',\
    \ (url, response, options) => {\n  var gdprConsent = \"&gdpr=1&gdpr_consent=TCFString\"\
    ;\n  var uspConsent = \"&us_privacy=1---\";\n  \n  assertThat(url).contains(gdprConsent);\n\
    \  assertThat(url).contains(uspConsent);\n  assertThat(url).contains(\"quantcount.com\"\
    );\n\n  return true;\n});\n\nrunCode(mockFields);\n\n// Verify that the tag finished\
    \ successfully.\nassertApi('gtmOnSuccess').wasCalled();"
- name: can parse consent object for tcloaded event and fire pixel to quantcount
  code: |-
    mockEventData.cmpConsents = JSON.stringify({
       "tcfApi":{
          "eventStatus":"tcloaded",
          "gdprApplies":false
       },
       "uspApi":{
          "version":1,
          "uspString":"1---"
       }
    });

    // test if the gdpr & usp_api strings are added to the URL
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).contains("&gdpr=0");
      assertThat(url).contains("&us_privacy=1---");
      assertThat(url).contains("quantcount.com");

      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: can parse consent object and fire pixel to quantserve
  code: "mockEventData.cmpConsents = JSON.stringify({\n   \"tcfApi\":{\n      \"cmpId\"\
    :10,\n      \"cmpVersion\":44,\n      \"gdprApplies\":true,\n      \"tcfPolicyVersion\"\
    :2,\n      \"eventStatus\":\"tcloaded\",\n      \"cmpStatus\":\"loaded\",\n  \
    \    \"listenerId\":0,\n      \"tcString\":\"TCFString\",\n      \"isServiceSpecific\"\
    :true,\n      \"useNonStandardStacks\":false,\n      \"purposeOneTreatment\":false,\n\
    \      \"publisherCC\":\"GB\",\n      \"outOfBand\":{\n         \"allowedVendors\"\
    :{},\n         \"disclosedVendors\":{}\n      },\n      \"purpose\":{\n      \
    \   \"consents\":{\n            \"1\":true,\n            \"2\":true,\n       \
    \     \"3\":true,\n            \"4\":true,\n            \"5\":true,\n        \
    \    \"6\":true,\n            \"7\":true,\n            \"8\":true,\n         \
    \   \"9\":true,\n            \"10\":true\n         },\n         \"legitimateInterests\"\
    :{\n            \"1\":false,\n            \"2\":true,\n            \"3\":true,\n\
    \            \"4\":true,\n            \"5\":true,\n            \"6\":true,\n \
    \           \"7\":true,\n            \"8\":true,\n            \"9\":true,\n  \
    \          \"10\":true\n         }\n      },\n      \"vendor\":{\n         \"\
    consents\":{\n            \"11\":true,\n            \"12\":false\n         },\n\
    \         \"legitimateInterests\":{\n            \"11\":true,\n            \"\
    12\":false\n         }\n      },\n      \"specialFeatureOptins\":{\n         \"\
    1\":true,\n         \"2\":true\n      },\n      \"publisher\":{\n         \"consents\"\
    :{\n            \n         },\n         \"legitimateInterests\":{\n          \
    \  \n         },\n         \"customPurpose\":{\n            \"consents\":{},\n\
    \            \"legitimateInterests\":{}\n         },\n         \"restrictions\"\
    :{}\n      },\n      \"addtlConsent\":\"\"\n   },\n   \"uspApi\":{\n      \"version\"\
    :1,\n      \"uspString\":\"1---\"\n   }\n});\n\n// test if the gdpr & usp_api\
    \ strings are added to the URL\nmock('sendPixelFromBrowser', (url, response, options)\
    \ => {\n  var gdprConsent = \"&gdpr=1&gdpr_consent=TCFString\";\n  var uspConsent\
    \ = \"&us_privacy=1---\";\n  \n  assertThat(url).contains(gdprConsent);\n  assertThat(url).contains(uspConsent);\n\
    \  assertThat(url).contains(\"quantserve.com\");\n\n  return true;\n});\n\nrunCode(mockFields);\n\
    \n// Verify that the tag finished successfully.\nassertApi('gtmOnSuccess').wasCalled();"
- name: can parse consent when CMP missing (null values)
  code: |
    mockEventData.cmpConsents = null;

    // test if the gdpr & usp_api strings are added to the URL
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).doesNotContain("gdpr=");
      assertThat(url).doesNotContain("us_privacy=");
      assertThat(url).contains("quantserve.com");

      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();

    mockEventData.cmpConsents = JSON.stringify({
       "tcfApi":null,
       "uspApi": null,
    });

    // test if the gdpr & usp_api strings are added to the URL
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).doesNotContain("gdpr=");
      assertThat(url).doesNotContain("us_privacy=");
      assertThat(url).contains("quantserve.com");

      return true;
    });

    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
- name: can append additional url parameters
  code: |-
    mockFields.parameters = {
      "some": "thing",
      "other": "thing",
    };

    // Mock pixel request
    mock('sendPixelFromBrowser', (url, response, options) => {
      assertThat(url).contains("&some=thing");
      assertThat(url).contains("&other=thing");
      return true;
    });


    // Call runCode to run the template's code.
    runCode(mockFields);

    // Verify that the tag finished successfully.
    assertApi('gtmOnSuccess').wasCalled();
setup: "const JSON = require('JSON');\n\nconst mockEventData = {\n  page_location:\"\
  example.com/path/to/page\",\n  ip_override:\"1.2.3.4\",\n  user_agent:\"Mozilla/5.0\
  \ (platform; rv:geckoversion) Gecko/geckotrail Firefox/firefoxversion\",\n  client_id:\
  \ 'some_client_id',\n};\n\nconst mockFields = {\n  qacct:\"p-123456789\", \n  labels:\"\
  _fp.event.Purchase.sneakers-casual\"\n};\n\nmock('getAllEventData', (eventDataKey)\
  \ => {\n  return mockEventData;\n});\n"


___NOTES___

Created on 10/10/2022, 15:40:07
